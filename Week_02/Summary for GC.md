## 1.Serial GC

#### 一个单线程的收集器，设计为在单核的环境下工作（32位或者windows. 在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。 

**特点：**CPU利用率最高，停顿时间即用户等待时间比较长。 

**适用场景：**小型应用 

**使用方法：**-XX:+UseSerialGC

##  2.Parallel GC

#### JVM默认的收集器，占用较低的CPU因而能提高应用的吞吐（throughput）

**优点：** 采用多线程来通过扫描并压缩堆 

**缺点：** 在minor和full GC的时候都会暂停应用的运行

**特点：**停顿时间短，回收效率高，对吞吐量要求高。

**适用场景：**大型应用，科学计算，大规模数据采集等可以容忍程序停滞的环境使用。 

**使用方法：** -XX:+USeParallelGC

##  3.CMS GC

#### 采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。 

CMS是Concurrent-Mark-Sweep的缩写，并发的标记与清除。这个算法使用多个线程并发地（concurrent）扫描堆，标记不使用的对象，然后清除它们回收内存。

在两种情况下会使应用暂停（Stop the World, STW）：

> 1. 当初次开始标记根对象时initial mark。
> 2. 当在并行收集时应用又改变了堆的状态时，需要它从头再确认一次标记了正确的对象final remark。

这个收集器最大的问题是在年轻代与老年代收集时会出现的一种竞争情况（race condition），称为提升失败promotion failure。对象从年轻代复制到老年代称为提升promotion，但有时侯老年代需要清理出足够空间来放这些对象，这需要一定的时间，它收集的速度可能赶不上不断产生的要提升的年轻代对象的速度，这时就需要做STW的收集。STW正是CMS想避免的问题。为了避免这个问题，需要增加老年代的空间大小或者增加更多的线程来做老年代的收集以赶上从年轻代复制对象的速度。

CMS最大的问题就是内存空间碎片化的问题。CMS只有在触发FullGC的情况下才会对堆空间进行compact。如果线上应用长时间运行，碎片化会非常严重，会很容易造成promotion failed。为了解决这个问题线上很多应用通过定期重启或者手工触发FullGC来触发碎片整理。

对比并行收集器它的一个坏处是**需要占用比较多的CPU**。对于大多数长期运行的服务器应用来说，这通常是值得的，因为它不会导致应用长时间的停滞。但是它不是JVM的默认的收集器。

使用CMS需要仔细分析自己的应用对象生命周期，尤其是在应用要求高性能，高吞吐。需要仔细分析自己应用所需要的heap大小，老年代，新生代的分配比例，以及survival区的大小。设置不合理会很容易造成性能问题。

（1）初始标记 

（2）并发标记 

（3）并发预处理 

（4）重新标记 

（5）并发清除 

（6）并发重置 

**特点：**响应时间优先，减少垃圾收集停顿时间 

**适应场景：**服务器、电信领域等。 

**使用方法：** -XX:+UseConcMarkSweepGC，可同时使用-XX:+UseParNewGC将并行收集作用于年轻代

##  4.G1 GC 

#### 在G1中，堆被划分成 许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。 

**如果你的堆内存大于4G的话，那么G1会是要考虑使用的收集器**。它是为了更好支持大于4G堆内存在JDK 7 u4引入的。G1收集器把堆分成多个区域，大小从1MB到32MB，并使用多个后台线程来扫描这些区域，优先会扫描最多垃圾的区域，这就是它名称的由来，垃圾优先Garbage First。

如果在后台线程完成扫描之前堆空间耗光的话，才会进行STW收集。它另外一个优点是它在处理的**同时会整理压缩堆空间**，相比CMS只会在完全STW收集的时候才会这么做。

使用过大的堆内存在过去几年是存在争议的，很多开发者从单个JVM分解成使用多个JVM的微服务（micro-service）和基于组件的架构。其他一些因素像分离程序组件、简化部署和避免重新加载类到内存的考虑也促进了这样的分离。

除了这些因素，最大的因素当然是避免在STW收集时JVM用户线程停滞时间过长，如果你使用了很大的堆内存的话就可能出现这种情况。另外，像Docker那样的容器技术让你可以在一台物理机器上轻松部署多个应用也加速了这种趋势。

**特点：**支持很大的堆，高吞吐量 

> 支持多CPU和垃圾回收线程  
>
> 在主线程暂停的情况下，使用并行收集  
>
> 在主线程运行的情况下，使用并发收集 

**实时目标：**可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收 

**使用方法：** –XX:+UseG1GC

